{
    "contents" : "#A simple example of how to construct y, X and W; the \n#absence-presence data, site covariates and observation covariates\n#-----------------------------------------------------------------\n\nrequire(MASS)\nset.seed(1000)\n\n#int, beta1, beta2\nbeta.param = c(-1.85, 1.5, -0.5)\nn = 500\n\n#create 2 site covariates used to model occupancy\nx1 = runif(n, -2,2) \nx1 = (x1 - mean(x1)) / sd(x1)\nx2 = runif(n, -5,5) \nx2 = (x2 - mean(x2)) / sd(x2) \nX = cbind(rep(1,n), x1, x2)\npsi = as.vector(1/(1+exp(-X %*% beta.param))) ##logistic link function used \nz = rbinom(n, size=1, prob=psi)\n\nJ = 3 #the maximum number of surveys (some sites might have fewer visits)\n\n#three observation covariates used to model the detection probs\n#int, alpha1, alpha2, alpha3\nalpha.param = c(-1.35, 1.0, 0.5, -.25) \nw1 = runif(n*J, -5,5)\nw1 = (w1 - mean(w1)) / sd(w1)\nw2 = runif(n*J, -1,1)\nw2 = (w2 - mean(w2)) / sd(w2)\nw3 = runif(n*J, 0,5)\nw3 = (w3 - mean(w3)) / sd(w3)\nW = array(dim=c(n,J,4))\nW[,,1] = 1\nW[,,2] = w1\nW[,,3] = w2\nW[,,4] = w3\n\np = matrix(nrow=n, ncol=J)\ny = matrix(nrow=n, ncol=J)\nfor (j in 1:J)\n{\n  p[, j] = c(1/(1+exp(-W[,j,] %*% alpha.param)))\n  y[, j] = rbinom(n, size=1, prob=z*p[, j]) \n}\n#-----------------------------------------------------------------\n\n#Now lets simulate the number of visits to each of the sites\n#i.e. we need to set some of the y and W entries equal to \n#NA\n# nvisits<-sample(1:J, n, replace=T)\n# empty.sites<-which(nvisits!= J)\n# \n# for (i in 1:length(empty.sites))\n# {\n#   #adds NA to sites with visits less than J\n#   y[ empty.sites[i], (nvisits[empty.sites[i]]+1):J ] <- NA\n#   \n#   #adds NA to W entries with visits less than J\n#   W[ empty.sites[i], (nvisits[empty.sites[i]]+1):J, ] <- NA \n# }\n\n#Note W[i,,] are the covariate values for site i\n#each row is for a specific visit\n#-----------------------------------------------------------------\n\n#An nxJ matrix of the observed measured data,\n#where n is the number of sites and J is the \n#maximum number of observations per site.\nY.eg<-y\n#-----------------------------------------------------------------\n\n#siteCovs  \n#A data.frame of covariates that vary at the site level. \n#This should have n rows and one column per covariate\nX.eg=as.data.frame(cbind(x1,x2))\ncolnames(X.eg)<-c(\"X1\",\"X2\")\n#-----------------------------------------------------------------\n\n#obsCovs  \n#the obsCovs matrix is constructed as per the 'unmarked' package\n#i.e. W.eg.l1 is a named list of data.frames of covariates that \n#vary within sites.\n#i.e. The dataframes are of dimension n by J\n#where each row is associated with a site\n#and each column represents a site visit. \n#e.g. W.eg.l1$W1[1, ] = the covariate values for site 1 for all of the\n#visits. Note that some of the entries might be 'NA'\n#meaning that no visit took place at those occasions.\n\nW1=matrix(NA,nrow=n, ncol=J)\nW2=matrix(NA, nrow=n, ncol=J)\nW3=matrix(NA, nrow=n, ncol=J)\nfor (i in 1:n)\n{ \n  W1[i,]<- W[i,,2]\n  W2[i,]<- W[i,,3]\n  W3[i,]<- W[i,,4] \n}\n\n#colnames(W1)<-paste(\"W1.\",1:J,sep=\"\")\n#colnames(W2)<-paste(\"W2.\",1:J,sep=\"\")\n#colnames(W3)<-paste(\"W3.\",1:J,sep=\"\")\n\nW.eg.l1<-list(W1=W1, W2=W2, W3=W3)\n#W.eg.l1\n#-----------------------------------------------------------------\n\n#An alternate way of 'viewing' the site covariates is as follows:\n#Create a list element; one for each site, where the data\n#for each site have been stacked one below the other either as \n#a dataframe or as a matrix. e.g.\n#W.eg.l2[[2]] is the data for site 2.\n\nW.eg.l2=list(list())\n#Here we assume that we do not have any missing values\nnvisits<-rep(J,n) #so equal visits to each site\n\nfor (i in 1:n)\n{\n  if (nvisits[i]!=1)\n  {\n    dframe<-as.data.frame(W[i,1:nvisits[i],][,-1])\n  }else\n  {\n    dframe<-as.data.frame(matrix(W[i,1:nvisits[i],][-1],nrow=1))\n  }\n  \n  names(dframe)<-c(\"W1\",\"W2\",\"W3\")\n  W.eg.l2[[i]]<-dframe\n}\n#-----------------------------------------------------------------\n\n#Two different ways of representing the observation covariates\n#not run\n#W.eg.l1\n#W.eg.l2\n#-----------------------------------------------------------------\n\n#If the site covariates are provided as per W.eg.l1\n#then we can construct W.eg as follows \n#(here W.eg is the way in which 'vb_model2_la')\n#creates the site covariate matrix W)\n#We assume that all sites are visited at least once\n#although all might not be visited J times\n#We further assume that there are no missing covariate\n#values for those occasions sites are visited\n\nW.temp<-NULL\nnv<-length(W.eg.l1)\nfor (i in 1:nv)\n{ \n  W.temp<-cbind(W.temp, W.eg.l1[[i]])\n}\n#W.temp\n\nnvisits<-apply(W.eg.l1[[1]],1,function(x){length(na.omit(x))})\n#nvisits\n\nW.eg<-NULL\nnv<-length(nvisits)\nfor (i in 1:nv)\n{\n  #print(matrix( c(na.omit(W.temp[i,])), nrow=nvisits[i]))\n  W.eg<-rbind(W.eg, matrix( c(na.omit(W.temp[i,])), nrow=nvisits[i]) )\n}\n#W.eg\ncolnames(W.eg)<-c(\"W1\",\"W2\",\"W3\")\n\n#-----------------------------------------------------------------\n\n#If the site covariates are provided as per W.eg.l2\n#then we can construct W.eg as follows\nW.eg<-NULL\nn <-length(W.eg.l2)\nfor (i in 1:n)\n{\n  W.eg<- rbind(W.eg, W.eg.l2[[i]])\n}\nW.eg\n#-----------------------------------------------------------------\n\nSimData2<-list(y=Y.eg, X=X.eg, W.eg.l1=W.eg.l1, W.eg.l2=W.eg.l2, W_vb=W.eg)\n#save(SimData2,file=\"SimData2.rda\")\n\nalpha_0 <- matrix(0, ncol=1, nrow=4) \nbeta_0 <- matrix(0, ncol=1, nrow=3)\nSigma_beta_0 <- diag(3)*1000\nSigma_alpha_0 <- diag(4)*1000\n\n#Here we use the large sample approximation and run the VB algorithm\n#-------------------------------------------------------------------\nvb_1<-vb_model2_la(W=W, X=X, y=y, alpha_0=alpha_0, beta_0=beta_0, Sigma_alpha_0=Sigma_alpha_0, Sigma_beta_0=Sigma_beta_0,LargeSample=TRUE, epsilon=1e-5)\n\ndim(W)\n#vb_model2_la<-function(W, X, y, \n                       \n#vb1<-vb_model2_la_2(y~ W=W, X=X, y=y, alpha_0=alpha_0, beta_0=beta_0, Sigma_alpha_0=Sigma_alpha_0, Sigma_beta_0=Sigma_beta_0,LargeSample=TRUE, epsilon=1e-5)\n\n\n                       \n                       \ndesign_mats<-vb_Designs(W=W.eg.l1, X=X.eg, y=y)\n#design_mats\n\n#sort out the named of the W matrix\nvb_eg<-vb_call(y~x1+x2~W1+W2+W3, design_mats=design_mats)\n#vb_call(y~x1.~W1+W3, design_mats=design_mats)\n\n\nvb_Designs_check<-function(formula, Names)\n{\n  #perform some checks on the design matrices\n  #check that the names in the formula call are in the dataframes provided\n  \n  detVars<-all.vars(formula)\n\n  if ( (sum(detVars[-1]%in% Names)==length(detVars[-1]))!= 1)\n  {\n    stop(print(\"\\n \\n CHECK YOUR FORMULA CALL. \\n MISMATCH BETWEEN CALL AND DESIGN MATRICES. \\n i.e. You included objects in the call: '~occupancy variables ~ detection variables' that does not appear in the design matrices.\"))\n    #stop()\n  } \n}\n\nvb_Designs<-function(W, X, y)\n{\n  #create the required 'response' and 'regressor matrices'\n  #using all of the X and W data\n  #the output is stored as a named list \n  \n  #create the Y matrix that will be used\n  Y<-matrix(na.omit(matrix(t(y), ncol=1)))\n  #col.names(Y)<-names(y)\n    \n  #create the W matrix\n  W.temp<-NULL\n  nv<-length(W)\n  \n  for (i in 1:nv){W.temp<-cbind(W.temp, W[[i]])}\n \n  nvisits<-apply(W[[1]],1,function(x){length(na.omit(x))})\n  n<-length(nvisits)\n \n  W.out<-NULL\n  for (i in 1:n){W.out<-rbind(W.out, matrix( c(na.omit(W.temp[i,])), nrow=nvisits[i]) )}\n  colnames(W.out)<-names(W)\n  \n  list(Y=as.data.frame(Y), X=as.data.frame(X), W=as.data.frame(W.out), Names=c( colnames(X), colnames(W.out)))\n}\n\nvb_ReqDesigns<-function(formula, design_mats)\n{\n  vb_Designs_check(formula, design_mats$Names)\n  \n  #create the W matrix\n  W<-model.matrix(as.formula(paste(\"~\",formula[3],sep=\"\")), data=design_mats$W)\n  #print(W)\n  \n  #create the X matrix\n  f_xmat<-paste(formula[[2]])\n  X<-model.matrix(as.formula(paste(f_xmat[1],f_xmat[3],sep=\"\")), data=design_mats$X)\n  #print(dim(X))\n  \n  list(W=W, X=X)\n}\n\nvb_call<-function(formula, design_mats)\n{\n  req_design_mats<-vb_ReqDesigns(formula, design_mats)\n  \n  W<-req_design_mats$W\n  X<-req_design_mats$X\n  Y<-design_mats$Y\n  \n  #print(X)\n  #print(W)\n  #return(req_design_mats)\n  \n}\n\ndesign_mats<-vb_Designs(W=W.eg.l1, X=X.eg, y=y)\n#design_mats\n\n#vb_call(y~x1+x2~w1+w2+ w3, design_mats=design_mats)\n#vb_call(y~x1.~W1+W3, design_mats=design_mats)\n\n\n#y~x1+x2~W1+W2+W3, \n\n#jj<-vb_Designs(X=X.eg, W=W.eg.l1, y=y)\n#jj\n\n#formula_e = the formula provided to the call\nformula_e<-y~x1~W1+W2+W3\nformula_e[[1]]\nformula_e[[2]]\nformula_e[[3]]\naa=all.vars(formula_e)[-1] #exclude the y \naa\n\nNames=c(\"x1\",\"x2\",\"W1\", \"W2\" , \"W3\")\nNames\n\naa\nNames\nsum(aa%in% Names)==length(aa)\n\n\nff<-paste(formula_e[[2]])\npaste(ff[1],ff[3],sep=\"\")\n\n\n",
    "created" : 1412003481484.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1348609748",
    "id" : "4A842B53",
    "lastKnownWriteTime" : 1412005391,
    "path" : "C:/Users/AllanClark/Dropbox/PhD/Year1/ISEC2014/OccupancyModel2/Package/vboccupancy/R/SomeSimulations2.R",
    "project_path" : "R/SomeSimulations2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}